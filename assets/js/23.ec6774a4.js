(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{431:function(e,t,s){"use strict";s.r(t);var a=s(2),r=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"cve-2018-19178-jeesns-v1-3-存储型xss"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cve-2018-19178-jeesns-v1-3-存储型xss"}},[e._v("#")]),e._v(" CVE-2018-19178---jeesns v1.3 存储型xss")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("漏洞触发点在CkeditorUploadController.java的第41行。文件在32行处获取了请求中的CKEditorFuncNum参数，然后在41行处输出在页面上导致了xss漏洞。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/Chenforcode/chen-imagebed/raw/master/img/20220128172158.png",alt:""}})])]),e._v(" "),t("li",[t("p",[e._v("这里可以跟进getParameter函数，进到XssHttpServletRequestWrapper.java文件。可以看到这里在返回参数信息的时候，进行了cleanXSS操作。下面我们跟进cleanXSS")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/Chenforcode/chen-imagebed/raw/master/img/20220128172439.png",alt:"image-20220128172438950"}})])]),e._v(" "),t("li",[t("p",[e._v("可以看到cleanXSS的功能是对script标签内的事件进行过滤。这里的逻辑是先对script标签等进行过滤，然后再过滤标签内的事件。那么对于first checkpoint，我们可以使用svg、img等标签进行绕过。而此处的xss触发并不需要利用script标签，因为上下文中已经有了（参考上面第一张图）。因此我们的输入只需要想办法绕过second checkpoint。而对于第二个checkpoint，我们可以使用事件的不同拼写方式来绕过，例如它检测的是onload，我们则使用onLoad，和第一张图进行拼凑，也就导致了xss的发生。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/Chenforcode/chen-imagebed/raw/master/img/20220128173522.png",alt:"image-20220128173522501"}})])]),e._v(" "),t("li",[t("p",[e._v("参考文献")]),e._v(" "),t("ul",[t("li",[e._v("https://github.com/Jayl1n/CVE/blob/master/jeesns/jeesns-1.3-xss-filter-bypass.md")]),e._v(" "),t("li",[e._v("https://www.cnpanda.net/codeaudit/605.html")])])])])])}),[],!1,null,null,null);t.default=r.exports}}]);